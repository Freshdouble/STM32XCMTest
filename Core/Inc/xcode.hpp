/**********************************************************************************************************************************
*
*		File: xcode.hpp
*		Date: 18 Jan 2022
*
*		This file was autogenerated using the xcode code generator.
*		Every addition to this file will be overwritten when new code is generated using the code generator.
*
*		Note: This code should only use packets with a maxsize known at compile time. So you can excpect that the GetMaxSize
*		      Memberfunction works on every packet in this file.
*
**********************************************************************************************************************************/

#ifndef USE_ETL
#define USE_ETL //Force etl to be bundeled with BaseCom because strings in this template need the etl::string implementation
#endif

#include <cstdint>
#include "BaseCom.hpp"
#include "etl/string.h"

#ifndef XCM_DEFINITIONS_HPP__
#define XCM_DEFINITIONS_HPP__

using namespace translib;

//{ Region MessageDefinitions

/********************************************************************************************************
Definitions for LEDStatus

********************************************************************************************************/
//{ Region LEDSTATUS
//{ Region Argument

//
struct LEDStatus_Argument : public Bitfield<8>
{
	static const size_t ledstatus_Offset = 0;
	static const size_t ledstatus_Length = 1;


	bool Read_ledstatus()
	{
		return GetData<bool>(ledstatus_Offset, ledstatus_Length);
	}
	void Write_ledstatus(bool data)
	{
		return WriteData(ledstatus_Offset, ledstatus_Length, data);
	}
};
//}
struct LEDStatus : public ComPacket<LEDStatus_Argument>
{

	const char* id = "MLS";
	static constexpr std::array<uint8_t, 3> idBytes = { 77,76,83 };
	static constexpr size_t packetLength = 3 + GetMaxSize();
	LEDStatus_Argument& argument = get<0>(elements);

	/**
	* @brief Checks if the id in data matches the id of this packet.
	*
	* If this function returns a match it used exactly idbytelength of bytes
	*
	* @tparam maxdatalength 
    * @param data 
    * @param length 
    * @return tuple<bool, size_t, size_t> If the packet start matches the id; The offset to the packet start; The remaining bytes in the packet.
	**/
	template<const size_t maxdatalength>
	static tuple<bool, size_t, size_t> IDMatch(const std::array<uint8_t, maxdatalength> &data,const size_t length)
	{
		assert(length <= maxdatalength);
		if(length <= maxdatalength)
		{
			auto [valid, iterator, remainingBytes] = CheckIDMatch(data, length, idBytes);
			return make_tuple(valid, std::distance(data.begin(), iterator), remainingBytes);
		}
		else
		{
			return make_tuple(false, 0, length);
		}
	}

#ifdef USE_MEMALLOC
	/**
    * @brief Serialize the packet to an newly created vector with the specified id data before the serialized data.
    * 
    * @return unique_ptr<vector<uint8_t>> 
    */
    unique_ptr<vector<uint8_t>> SerializeWithID() const
    {
		return Serialize(idBytes);
	}
#endif

	/**
    * @brief Serialize the packet to the buffer starting at begin and ending on end.
    *
    * @tparam datalength
    * @param buffer - The array to hold the data
    * @return size_t - Byte length of the serialized data
    */
    template <const size_t datalength>
    size_t SerializeWithID(array<uint8_t, datalength> &buffer) const
    {
        return Serialize(buffer, idBytes);
    }

	/**
    * @brief Serialize the packet and returns the length of the serialized data and the data itself.
    *
    * @return std::tuple<size_t, std::array<uint8_t, packetLength>> Datalength; The data of the packet.
    */
	std::tuple<size_t, std::array<uint8_t, packetLength>> SerializeWithID() const
	{
		std::array<uint8_t, packetLength> data;
		size_t datalength = SerializeWithID(data);
		return std::make_tuple(datalength, data);
	}
};
//}
/********************************************************************************************************/

enum class Messages
{
	LEDStatus,
	Unkown
};

template<Messages message> struct get_message;
template<> struct get_message<Messages::LEDStatus>{ typedef LEDStatus type;};

template<const size_t maxdatalength>
auto GetMatchedMessage(const std::array<uint8_t, maxdatalength> &data, size_t length)
{
	std::tuple<bool, size_t, size_t> ret;
	if(std::get<0>(ret = LEDStatus::IDMatch(data, length))) return std::make_tuple(Messages::LEDStatus, std::get<1>(ret), std::get<2>(ret));
	return std::make_tuple(Messages::Unkown, 0U, 0U);
}
//}

//{ Region CommandDefinitions

/********************************************************************************************************
Definitions for SetLEDStatus

********************************************************************************************************/
//{ Region SETLEDSTATUS
//{ Region Argument

//
struct SetLEDStatus_Argument : public Bitfield<8>
{
	static const size_t ledstatus_Offset = 0;
	static const size_t ledstatus_Length = 1;


	bool Read_ledstatus()
	{
		return GetData<bool>(ledstatus_Offset, ledstatus_Length);
	}
	void Write_ledstatus(bool data)
	{
		return WriteData(ledstatus_Offset, ledstatus_Length, data);
	}
};
//}
struct SetLEDStatus : public ComPacket<SetLEDStatus_Argument>
{

	const char* id = "CS";
	static constexpr size_t idbytelength = 2;
	static constexpr std::array<uint8_t, idbytelength> idBytes = { 67,83 };
	static constexpr size_t packetLength = idbytelength + GetMaxSize();
	SetLEDStatus_Argument& argument = get<0>(elements);

	/**
	* @brief Checks if the id in data matches the id of this packet.
	*
	* If this function returns a match it used exactly idbytelength of bytes
	*
	* @tparam maxdatalength 
    * @param data 
    * @param length 
    * @return tuple<bool, size_t, size_t> If the packet start matches the id; The offset to the packet start; The remaining bytes in the packet.
	**/
	template<const size_t maxdatalength>
	static tuple<bool, size_t, size_t> IDMatch(const std::array<uint8_t, maxdatalength> &data,const size_t length)
	{
		assert(length <= maxdatalength);
		if(length <= maxdatalength)
		{
			auto [valid, iterator, remainingBytes] = CheckIDMatch(data, length, idBytes);
			return make_tuple(valid, std::distance(data.begin(), iterator), remainingBytes);
		}
		else
		{
			return make_tuple(false, 0, length);
		}
	}

#ifdef USE_MEMALLOC
	/**
    * @brief Serialize the packet to an newly created vector with the specified id data before the serialized data.
    * 
    * @return unique_ptr<vector<uint8_t>> 
    */
    unique_ptr<vector<uint8_t>> SerializeWithID() const
    {
		return Serialize(idBytes);
	}
#endif

	/**
    * @brief Serialize the packet to the buffer starting at begin and ending on end.
    *
    * @tparam datalength
    * @param buffer - The array to hold the data
    * @return size_t - Byte length of the serialized data
    */
    template <const size_t datalength>
    size_t SerializeWithID(array<uint8_t, datalength> &buffer) const
    {
        return Serialize(buffer, idBytes);
    }

	/**
    * @brief Serialize the packet and returns the length of the serialized data and the data itself.
    *
    * @return std::tuple<size_t, std::array<uint8_t, packetLength>> Datalength; The data of the packet.
    */
	std::tuple<size_t, std::array<uint8_t, packetLength>> SerializeWithID() const
	{
		std::array<uint8_t, packetLength> data;
		size_t datalength = SerializeWithID(data);
		return std::make_tuple(datalength, data);
	}
};
//}
/********************************************************************************************************/

enum class Commands
{
	SetLEDStatus,
	Unkown
};

template<Commands message> struct get_command;
template<> struct get_command<Commands::SetLEDStatus>{ typedef SetLEDStatus type;};

template<const size_t maxdatalength>
auto GetMatchedCommand(const std::array<uint8_t, maxdatalength> &data, size_t length)
{
	std::tuple<bool, size_t, size_t> ret;
	if(std::get<0>(ret = SetLEDStatus::IDMatch(data, length))) return std::make_tuple(Commands::SetLEDStatus, std::get<1>(ret), std::get<2>(ret));
	return std::make_tuple(Commands::Unkown, 0U, 0U);
}
//}
#endif